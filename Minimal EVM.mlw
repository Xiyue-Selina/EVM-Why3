module EVM
(* Focus on machine state: Program Counter, Gas Available, Stack Contents, Memory Contents which are volatile Machine state;
with the account storage as persistent world state *)

(* the library support *)
use import array.Array
use import int.Int (* Arithmetic *)
use import list.ListRich (* combo theory that includes all list operations like length, reversal, and concatenation *)
use import option.Option
use import UInt256
use import UInt160
use import UInt8
use mach.int.Unsigned

(* Use clear alias for commonly-used type *)


(* 32-bit and 64-bit signed and unsigned integers ([Int32], [UInt32], [Int64], and [UInt64]) as well as 31-bit and 
63-bit signed integers ([Int31] and [Int63] have been instantiated *)
(* They can be transformed using to_int and of_int, which can be further encapsulated for other transformation between type *) 
type byte = uint8
type address = uint160
type machword = uint256

(* Set explicit type transformation, such as machword to address, machword to byte in each newly-built library,
encapsulated as a direct function, e.g. to_int and of_int to a function *)

(* memory: word addressed byte array *)
(* stack: one way of model is modeled as list uint256, with a maximum size of 1024 *)
(* storage(independent): word addressed word array, maintained as part of the system state *)

(* Enumeration type*)
type memory_content = 
   | Item8
   | Item256
type memory = machword -> option memory_content
type stack = list uint256
type storage = machword -> machword (* machine word -> machine word *)

(* EVM status *)
(* TODO *)

type error =
    | OutOfBounds
    | OutOfGas
    | OutOfStack
    | OutOfCode
    | OutOfData
    | InvalidOpcode

type return_type =
  | Normal of uint256
  | Create of uint256
  | Revert

type vmstatus =
  | Running
  | Error of error
  | Finish of return_type

(* EVM Operations *)

(* Record the number of items required on the stack and returned to the stack for a given operation *)
type st_num = int * int

(* Bits *)
type bits_inst =
    | BIT_AND  
    | BIT_OR
    | BIT_XOR
    | BIT_NOT
    | BYTE (* take one byte out of a word *)


let bit_inst_opcode (inst: bits_inst): byte =
    match inst with 
        | BIT_AND -> 0X16
        | BIT_OR -> 0X17
        | BIT_XOR -> 0X18
        | BIT_NOT -> 0X19
        | BYTE -> 0X1a
    end

let bit_inst_num (inst: bits_inst): st_num =
    match inst with 
        | BIT_AND -> (2, 1)
        | BIT_OR -> (2, 1)
        | BIT_XOR -> (2, 1)
        | BIT_NOT -> (1, 1)
        | BYTE -> (2, 1)
    end

(* Signed Arithmetics *)
type sign_arith_inst =
| SDIV
| SMOD
| SLT
| SGT
| SEXTEND

let sign_arith_inst_opcode (inst: sign_arith_inst): byte =
match inst with 
| SDIV -> 0X05
| SMOD -> 0X07
| SLT -> 0X12
| SGT -> 0X13
| SEXTEND -> 0X0b 
end   

let sign_arith_inst_num (inst: sign_arith_inst): st_num =
match inst with 
| SDIV -> (2, 1)
| SMOD -> (2, 1)
| SLT -> (2, 1)
| SGT -> (2, 1)
| SEXTEND -> (2, 1)
end   
          
(* Unsigned Arithmetics *)
type arith_inst =
| ADD
| MUL
| SUB
| DIV
| MOD
| ADDMOD
| MULMOD
| EXP
| ARITH_LT
| ARITH_GT
| ARITH_EQ
| ISZERO
| SHA3

let arith_inst_opcode (inst: arith_inst): byte =
match inst with 
| ADD -> 0X01
| MUL -> 0X02
| SUB -> 0X03
| DIV -> 0X04
| MOD -> 0X06
| ADDMOD -> 0X08
| MULMOD -> 0X09
| EXP -> 0X0a
| ARITH_LT -> 0X10
| ARITH_GT -> 0X11
| ARITH_EQ -> 0X14
| ISZERO -> 0X15
| SHA3 -> 0X20
end

let arith_inst_num (inst: arith_inst): st_num =
match inst with 
| ADD -> (2, 1)
| MUL -> (2, 1)
| SUB -> (2, 1)
| DIV -> (2, 1)
| MOD -> (2, 1)
| ADDMOD -> (3, 1)
| MULMOD -> (3, 1)
| EXP -> (2, 1)
| ARITH_LT -> (2, 1)
| ARITH_GT -> (2, 1)
| ARITH_EQ -> (2, 1)
| ISZERO -> (1, 1)
| SHA3 -> (2, 1)
end

(* Information *)
type info_inst =
| ADDRESS
| BALANCE
| ORIGIN (* The external account that started the transaction *)
| CALLER
| CALLVALUE
| CALLDATASIZE
| CODESIZE
| GASPRICE
| EXTCODESIZE (* Size of the code of a specified account *)
| BLOCKHASH
| COINBASE (* The address of the miner that validates the current block *)
| TIMESTAMP
| NUMBER
| DIFFICULTY
| GASLIMIT
| GAS


let info_inst_opcode (inst: info_inst): byte =
match inst with
| ADDRESS -> 0X30
| BALANCE -> 0X31
| ORIGIN -> 0X32
| CALLER -> 0X33
| CALLVALUE -> 0X34
| CALLDATASIZE -> 0X36
| CODESIZE -> 0X38
| GASPRICE -> 0X3a
| EXTCODESIZE -> 0X3b
| BLOCKHASH -> 0X40
| COINBASE -> 0X41 
| TIMESTAMP -> 0X42
| NUMBER -> 0X43
| DIFFICULTY -> 0X44
| GASLIMIT -> 0X45
| GAS -> 0X5a
end

let info_inst_num (inst: info_inst): st_num =
match inst with
| ADDRESS -> (0, 1)
| BALANCE -> (1, 1)
| ORIGIN -> (0, 1)
| CALLER -> (0, 1)
| CALLVALUE -> (0, 1)
| CALLDATASIZE -> (0, 1)
| CODESIZE -> (0, 1)
| GASPRICE -> (0, 1)
| EXTCODESIZE -> (1, 1)
| BLOCKHASH -> (1, 1)
| COINBASE -> (0, 1) 
| TIMESTAMP -> (0, 1)
| NUMBER -> (0, 1)
| DIFFICULTY -> (0, 1)
| GASLIMIT -> (0, 1)
| GAS -> (0, 1)
end

(* Memory Operations *)
type memory_inst =
| MLOAD 
| MSTORE 
| MSTORE8 
| MSIZE (* the size of the currently used part of the memory *)
| CALLDATACOPY (* copy the caller's data to the memory *)
| CODECOPY (* copy part of the currently running code to the memory *)
| EXTCODECOPY (* copy part of the code of a specified account *)

let memory_inst_opcode (inst: memory_inst) : byte =
match inst with 
| MLOAD -> 0X51 
| MSTORE -> 0X52 
| MSTORE8 -> 0X53 
| MSIZE -> 0X59 (* the size of the currently used part of the memory *)
| CALLDATACOPY -> 0X37 (* copy the caller's data to the memory *)
| CODECOPY -> 0X39(* copy part of the currently running code to the memory *)
| EXTCODECOPY -> 0X3c(* copy part of the code of a specified account *)
end

let memory_inst_num (inst: memory_inst) : st_num =
match inst with 
| MLOAD -> (1, 1) 
| MSTORE -> (2, 0) 
| MSTORE8 -> (2, 0) 
| MSIZE -> (0, 1)(* the size of the currently used part of the memory *)
| CALLDATACOPY -> (3, 0) (* copy the caller's data to the memory *)
| CODECOPY -> (3, 0)(* copy part of the currently running code to the memory *)
| EXTCODECOPY -> (4, 0)(* copy part of the code of a specified account *)
end


(* Storage Operations *)
type storage_inst =
| SLOAD (* Read one word from the storage *)
| SSTORE (* Write one word to the storage *)

let storage_inst_opcode (inst: storage_inst): byte = 
match inst with 
| SLOAD -> 0X54(* Read one word from the storage *)
| SSTORE -> 0X55 (* Write one word to the storage *)
end

let storage_inst_num (inst: storage_inst): st_num = 
match inst with 
| SLOAD -> (1, 1)(* Read one word from the storage *)
| SSTORE -> (2, 0) (* Write one word to the storage *)
end

(*Program Counter Operation *)
type pc_inst =
 | JUMP (* jumping to the specified location in the code *)
 | JUMPI (* jumping to the specified location in the code if a condition is met *)
 | PC (* the current location in the code *)
 | JUMPDEST (* indicate jump destinations. *)

let pc_inst_opcode (inst: pc_inst): byte = match inst with
| JUMP -> 0X56
| JUMPI -> 0X57
| PC -> 0X58
| JUMPDEST -> 0X5b
end

let pc_inst_num (inst: pc_inst): st_num = match inst with
| JUMP -> (1, 0)
| JUMPI -> (2, 0)
| PC -> (0, 1)
| JUMPDEST -> (0, 0)
end


(* Stack Operations *)

(* 32 PUSH operations in total *)
(* The pushed value is represented by a list of bytes. *)

type stack_inst =
  | POP (* throw away the top element of the stack *)
  | PUSH_N of list byte (* pushing an element to the stack *) (* TODO Confirm this type representation "of" which is right in ocaml *)
  | CALLDATALOAD (* push a word to the stack which is taken from the caller's data *)

exception PushError

let stack_inst_opcode (inst: stack_inst): list byte 
raises {PushError -> False}
= match inst with
| POP -> [0X50]
| PUSH_N lst ->
     if 1 <= length(lst) <= 32 then [uint8_of_int (length lst) + 0X5f] ++ lst else raise PushError 
     (* opcode of the operation ++ the pushed value list *)
| CALLDATALOAD -> [0X35]
end

let stack_inst_num (inst: stack_inst): st_num = match inst with
| POP -> (1, 0)
| PUSH_N _ -> (0, 1)
| CALLDATALOAD -> (1, 1)
end

(* The 16 insts for duplicating a stack element, take a stack element and copy it on top of the stack *)
type dup_inst = uint4

let dup_inst_opcode (inst: dup_inst): byte =
(uint8_of_int (uint4_to_int inst) + 0X80) 

let dup_inst_num (inst: dup_inst): st_num =
(uint4_to_int inst, (uint4_to_int inst) + 1 )

(* The 16 insts for taking a stack element and duplicate it on top of the stack.*)
type swap_inst = uint4

let swap_inst_opcode (inst: swap_inst): byte =
  (uint8_of_int (uint4_to_int inst) + 0X90)

let swap_inst_num (inst: swap_inst): st_num =
((uint4_to_int inst) + 1, (uint4_to_int inst) + 1)

(* Logging Operations *)
(* The state change is to append an additional log entry on to the substateâ€™s log series *)
type log_inst =
| LOG0
| LOG1
| LOG2
| LOG3
| LOG4

let log_inst_opcode (inst: log_inst): byte = match inst with
| LOG0 -> 0Xa0
| LOG1 -> 0Xa1
| LOG2 -> 0Xa2
| LOG3 -> 0Xa3
| LOG4 -> 0Xa4
end

let log_inst_num (inst: log_inst): st_num = match inst with
| LOG0 -> (2, 0)
| LOG1 -> (3, 0)
| LOG2 -> (4, 0)
| LOG3 -> (5, 0)
| LOG4 -> (6, 0)
end

(* System Operations *)
type system_inst =
  | STOP (* finishing the execution normally, with the empty return data *)
  | CREATE (* deploying some code in an account *)
  | CALL (* calling (i.e. sending a message to) an account *)
  | CALLCODE (* calling into this account, but the executed code can be some other account's *)
  | RETURN (* finishing the execution normally with data *)
  | DELEGATECALL (* calling into this account, the executed code can be some other account's
                       but the sent value and the sent data are unchanged. *)
  | SELFDESTRUCT (* send all remaining Eth balance to the specified account, *)
            (* finishing the execution normally, and flagging the current account for deletion *)

let system_inst_opcode (inst: system_inst): byte = match inst with
| STOP -> 0X00
| CREATE -> 0Xf0
| CALL -> 0Xf1
| CALLCODE -> 0Xf2
| RETURN -> 0Xf3
| DELEGATECALL -> 0Xf4
| SELFDESTRUCT -> 0Xff
end

let system_inst_num (inst: system_inst): st_num = match inst with
| STOP         -> (0, 0)
| CREATE       -> (3, 1)
| CALL         -> (7, 1)
| CALLCODE     -> (7, 1)
| RETURN       -> (2, 0)
| DELEGATECALL -> (6, 1)
| SELFDESTRUCT -> (1, 0)
end

(* Instruction Set *)
(* The previous operation sets above are here combined into a single type. *)

type instruction =
  | Unknown of byte
  | Bits of bits_inst
  | Sarith of sign_arith_inst
  | Arith of arith_inst
  | Info of info_inst
  | Dup of dup_inst
  | Memory of memory_inst
  | Storage of storage_inst
  | Pc of pc_inst
  | Stack of stack_inst
  | Swap of swap_inst
  | Log of log_inst
  | System of system_inst

(*let to_list m = 
match m with
 | None -> Nil
 | Some s -> [s]
end*)


let inst_opcode (inst: instruction): list byte = match inst with
| Unknown byte -> [byte]
| Bits b -> [bits_inst_opcode b]
| Sarith s -> [sign_arith_inst_opcode s]
| Arith a -> [arith_inst_opcode a]
| Info i -> [info_inst_opcode i]
| Dup d -> [dup_inst_opcode d]
| Memory m -> [memory_inst_opcode m]
| Storage s -> [storage_inst_opcode s]
| Pc p -> [pc_inst_opcode p]
| Stack s -> stack_inst_opcode s
| Swap s -> [swap_inst_opcode s]
| Log l -> [log_inst_opcode l]
| System m -> [system_inst_opcode m]
end


let inst_stack_num (inst: instruction): st_num = match inst with
| Bits b -> bit_inst_num b
| Sarith s -> sign_arith_inst_num s
| Arith a -> arith_inst_num a
| Info i -> info_inst_num i
| Dup d -> dup_inst_num d
| Memory m -> memory_inst_num m
| Storage s -> storage_inst_num s
| Pc p -> pc_inst_num p
| Stack s -> stack_inst_num s
| Swap s -> swap_inst_num s
| Log l -> log_inst_num l
| System m -> system_inst_num m
end






(* Gas mechanism (Fee schedule) *)


let Gzero: int = 0
let Gbase: int = 2
let Gverylow: int = 3
let Glow: int = 5
let Gmid: int = 8
let Ghigh: int = 10
let Gextcode: int = 700 (* Amount of gas to pay for operations of the set Wextcode *)
let gas_of_Wzero (inst: instruction) : int =
  let Gas = match inst with
    |STOP
    |RETURN
    |REVERT -> 0
    end
  in Gas

let gas_of_Wlow (inst: instruction) : int =
  let Gas = match inst with
    |MUL
    |DIV
    |SDIV
    |MOD
    |SMOD
    |SIGNEXTEND -> 0
    end
  in Gas   

let Gbalance: int = 400
let Gsload: int = 200
let Gjumpdest: int = 1
let Gsset: int = 20000

let Gsreset: int = 5000
let Gselfdestruct: int = 5000

let Gcreate: int = 32000

let Gcodedeposit: int = 200
let Gcall: int = 700
let Gcallvalue: int = 9000

let Gcallstipend: int = 2300

let Gnewaccount: int = 25000

let Gexp: int = 10
let Gexpbyte: int = 50
let Gmemory: int = 3

let Gtxcreate: int = 32000

let Gtxdatazero: int = 4

let Gtxdatanonzero: int = 68

let Gtransaction: int = 21000

let Glog: int = 375

let Glogdata: int = 8

let Glogtopic: int = 375

let Gsha3: int = 30

let Gsha3word: int = 6

let Gcopy: int = 3

let Gblockhash: int = 20

let Gquaddivisor: int = 100

(* !!! Move to the preprocessor part: begin *)


type program = {
  program_content : int -> option instruction; 
  program_length  : int; (* the length of the program in bytes *)
}

let inst_list_of_program(p: program) (idx: int): byte =
   match p.program_content idx with
   | None -> 0
   | Some instruction ->
      match List.nth 0 (inst_opcode inst) with
      | None -> 0
      | Some a -> a
      end
   end


(* Move to the preprocessor part: end *)

(* Representation of the machine state part i.e. the volatile part *)
type machine_state = {
  mac_stack : stack ; (* In EVM definition, max length is 1024 *)
  mac_memory : memory;
  mac_pc : int;
  mac_status : vmstatus
  mac_memory_usage : int; (* the current memory usage *) 
  mac_gas : int; (* the remaining gas *)
  mac_insts : list instruction  (* Slight changes *)
  jumpmap : uint256 -> uint
}



(* The result of a program execution is the results of its instructions contained in the program *)

(* Move to the processor part *)
(* The next instruction *)
let next_instruction (m: machine_state) : option instruction  =
  match m.mac_pc with
  | Some i -> Some i
  | None -> Some (System STOP)
  end

(* Advancing the program counter: *)
let advance_pc (m: machine_state) : machine_state =
{ m with m.mac_pc =
     (match next_instruction m with
     | None -> m.mac_pc + 1
     | Some inst -> m.mac_pc + (inst_size inst) 
     end) 
}





(* Auxiliary functions for EVM instructions *)  

(* Auxiliary functions for memory *)
(* Memory initialization*)

let empty_memo: memory = fun addr: machword -> None

let rec update_memoContent (memo: memory) (idx: uint256) (cont: list memory_content) (n: int): memory 
requires {n >= 0}
=   match n with 
      | 0 -> memo
      | m + 1 -> 
        match cont with 
          | Nil -> memo
          | h :: t -> update_memoContent (fun addr -> if addr = idx then h else memo addr) (idx + 1) t m
        end
    end

let rec read_memoContent (idx: uint256) (n: int) (memo: memory): list memory_content
    requires {n >= 0}
= match n with 
    | 0 -> Nil
    | m + 1 -> memo idx :: read_memoContent (idx + 1) m memo
  end

(* Auxiliary functions for stack *)

let push_stack (s: stack) (ele: machword): stack = ele :: s

let pop_stack (s: stack): stack * option machword  = 
    match s with
    | ele :: (tl s) -> (tl s, Some ele)
    | _ -> (s, None) 
    end

(* Machine state update *)

let update_stack (st: stack) (m: machine_state) : machine_state =
{ m with mac_stack = st }   

let update_memory (memo: memory) (m: machine_state) : machine_state =
{ m with mac_memory = memo }  

let update_pc (pc: int) (m: machine_state) : machine_state =
{ m with mac_pc = pc }   

let update_status (vst: vmstatus) (m: machine_state) : machine_state =
{ m with mac_status = vst }  


(* Auxiliay function for the slight change in machine state to get the opcodes *)

let get_inst (mac_st: machine_state) =
  match mac_st with 
  | _ _ pc _ _ _ insts _ -> List.nth pc insts 
  end

(* Transformation semantics for different insturctions *)

let interpreter: machine_state -> machine_state =
   fun mac_st -> 
   let inst = get_inst mac_st in
   match inst with 
   | System STOP -> update_status mac_st (Finish (Normal (uint256_of_int 0)))

   end