module EVM
(* Focus on machine state: Program Counter, Gas Available, Stack Contents, Memory Contents which are volatile Machine state;
with the account storage as persistent world state *)

(* the library support *)
use import array.Array
use import int.Int (* Arithmetic *)
use import list.ListRich (* combo theory that includes all list operations like length, reversal, and concatenation *)
use import option.Option
use import UInt256
use import UInt160
use import UInt8
use mach.int.Unsigned

(* Use clear alias for commonly-used type *)


(* 32-bit and 64-bit signed and unsigned integers ([Int32], [UInt32], [Int64], and [UInt64]) as well as 31-bit and 
63-bit signed integers ([Int31] and [Int63] have been instantiated *)
(* They can be transformed using to_int and of_int, which can be further encapsulated for other transformation between type *) 
type byte = uint8
type address = uint160
type machword = uint256

(* Set explicit type transformation, such as machword to address, machword to byte in each newly-built library,
encapsulated as a direct function, e.g. to_int and of_int to a function *)

(* memory: word addressed byte array *)
(* stack: one way of model is modeled as list uint256, with a maximum size of 1024 *)
(* storage(independent): word addressed word array, maintained as part of the system state *)

(* Enumeration type*)
type memory_content = 
   | Item8 of uint256
   | Item256 of uint256
type memory = machword -> option memory_content
type stack = list uint256
type storage = machword -> machword (* machine word -> machine word *)

(* EVM status *)
(* TODO *)

type error =
    | OutOfBounds
    | OutOfGas
    | OutOfStack
    | OutOfCode
    | OutOfData
    | InvalidOpcode

type return_type =
  | Normal uint256
  | Create uint256
  | Revert

type vmstatus =
  | Running
  | Error error
  | Finish return_type

(* EVM Operations *)

(* Record the number of items required on the stack and returned to the stack for a given operation *)
type st_num = int * int

(* Bits *)
type bits_inst =
    | AND  
    | OR
    | XOR
    | NOT
    | BYTE (* Retrieve single byte from word *)


let bit_inst_opcode (inst: bits_inst): byte =
    match inst with 
        | AND -> 0X16
        | OR -> 0X17
        | XOR -> 0X18
        | NOT -> 0X19
        | BYTE -> 0X1a
    end

let bit_inst_num (inst: bits_inst): st_num =
    match inst with 
        | AND -> (2, 1)
        | OR -> (2, 1)
        | XOR -> (2, 1)
        | NOT -> (1, 1)
        | BYTE -> (2, 1)
    end

(* Signed Arithmetics *)
type sign_arith_inst =
| SDIV
| SMOD
| SLT
| SGT
| SIGNEXTEND (* Extend length of two's complement signed integer *)

let sign_arith_inst_opcode (inst: sign_arith_inst): byte =
match inst with 
| SDIV -> 0X05 (*  Signed integer division operation (truncated) *)
| SMOD -> 0X07
| SLT -> 0X12
| SGT -> 0X13
| SIGNEXTEND -> 0X0b 
end   

let sign_arith_inst_num (inst: sign_arith_inst): st_num =
match inst with 
| SDIV -> (2, 1)
| SMOD -> (2, 1)
| SLT -> (2, 1)
| SGT -> (2, 1)
| SIGNEXTEND -> (2, 1)
end   
          
(* Unsigned Arithmetics *)
type arith_inst =
| ADD
| MUL
| SUB
| DIV
| MOD
| ADDMOD (*  Modulo addition operation. *)
| MULMOD (*  Modulo multiplication operation. *)
| EXP (* Exponential operation. *)
| LT
| GT
| EQ
| ISZERO
| SHA3

let arith_inst_opcode (inst: arith_inst): byte =
match inst with 
| ADD -> 0X01
| MUL -> 0X02
| SUB -> 0X03
| DIV -> 0X04
| MOD -> 0X06
| ADDMOD -> 0X08
| MULMOD -> 0X09
| EXP -> 0X0a
| ARITH_LT -> 0X10
| ARITH_GT -> 0X11
| ARITH_EQ -> 0X14
| ISZERO -> 0X15
| SHA3 -> 0X20
end

let arith_inst_num (inst: arith_inst): st_num =
match inst with 
| ADD -> (2, 1)
| MUL -> (2, 1)
| SUB -> (2, 1)
| DIV -> (2, 1)
| MOD -> (2, 1)
| ADDMOD -> (3, 1)
| MULMOD -> (3, 1)
| EXP -> (2, 1)
| ARITH_LT -> (2, 1)
| ARITH_GT -> (2, 1)
| ARITH_EQ -> (2, 1)
| ISZERO -> (1, 1)
| SHA3 -> (2, 1)
end

(* Information *)
type info_inst =
| ADDRESS
| BALANCE
| ORIGIN (* Get execution origination address.*)
| CALLER
| CALLVALUE
| CALLDATASIZE
| CODESIZE
| GASPRICE (* Get price of gas in current environment *)
| EXTCODESIZE (* Size of the code of a specified account *)
| EXTCODECOPY (* Copy an account's code to memory *)
| RETURNDATASIZE (* Get size of output data from the previous call from the current environment *)
| RETURNDATACOPY (* Copy output data from the previous call to memory *)
| BLOCKHASH (* Get the hash of one of the 256 most recent complete blocks. *)
| COINBASE (* Get the block’s beneficiary address. *)
| TIMESTAMP
| NUMBER
| DIFFICULTY (* Get the block's difficulty *)
| GASLIMIT (*  Get the block's gas limit *)
| GAS


let info_inst_opcode (inst: info_inst): byte =
match inst with
| ADDRESS -> 0X30
| BALANCE -> 0X31
| ORIGIN -> 0X32
| CALLER -> 0X33
| CALLVALUE -> 0X34
| CALLDATASIZE -> 0X36
| CODESIZE -> 0X38
| GASPRICE -> 0X3a
| EXTCODESIZE -> 0X3b
| EXTCODECOPY  -> 0X3c
| RETURNDATASIZE -> 0X3d
| RETURNDATACOPY -> 0X3e
| BLOCKHASH -> 0X40
| COINBASE -> 0X41 
| TIMESTAMP -> 0X42
| NUMBER -> 0X43
| DIFFICULTY -> 0X44
| GASLIMIT -> 0X45
| GAS -> 0X5a
end

let info_inst_num (inst: info_inst): st_num =
match inst with
| ADDRESS -> (0, 1)
| BALANCE -> (1, 1)
| ORIGIN -> (0, 1)
| CALLER -> (0, 1)
| CALLVALUE -> (0, 1)
| CALLDATASIZE -> (0, 1)
| CODESIZE -> (0, 1)
| GASPRICE -> (0, 1)
| EXTCODESIZE -> (1, 1)
| EXTCODECOPY  -> (4, 0) 
| RETURNDATASIZE -> (0, 1)
| RETURNDATACOPY -> (3, 0)
| BLOCKHASH -> (1, 1)
| COINBASE -> (0, 1) 
| TIMESTAMP -> (0, 1)
| NUMBER -> (0, 1)
| DIFFICULTY -> (0, 1)
| GASLIMIT -> (0, 1)
| GAS -> (0, 1)
end

(* Memory Operations *)
type memory_inst =
| MLOAD 
| MSTORE 
| MSTORE8 
| MSIZE (* the size of the currently used part of the memory *)
| CALLDATACOPY (* copy the caller's data to the memory *)
| CODECOPY (* copy part of the currently running code to the memory *)
| EXTCODECOPY (* copy part of the code of a specified account *)

let memory_inst_opcode (inst: memory_inst) : byte =
match inst with 
| MLOAD -> 0X51 (* Load word from memory *)
| MSTORE -> 0X52 (* Save word to memory *)
| MSTORE8 -> 0X53 (* Save byte to memory *)
| MSIZE -> 0X59 (* the size of the currently used part of the memory *)
| CALLDATACOPY -> 0X37 (* copy the caller's data to the memory *)
| CODECOPY -> 0X39(* copy part of the currently running code to the memory *)
| EXTCODECOPY -> 0X3c(* copy part of the code of a specified account *)
end

let memory_inst_num (inst: memory_inst) : st_num =
match inst with 
| MLOAD -> (1, 1) 
| MSTORE -> (2, 0) 
| MSTORE8 -> (2, 0) 
| MSIZE -> (0, 1)(* Copy code running in current environment to memory *)
| CALLDATACOPY -> (3, 0) (* copy the caller's data to the memory *)
| CODECOPY -> (3, 0)(* copy part of the currently running code to the memory *)
| EXTCODECOPY -> (4, 0)(* copy part of the code of a specified account *)
end


(* Storage Operations *)
type storage_inst =
| SLOAD (*Load word from the storage *)
| SSTORE (* Save word to the storage *)

let storage_inst_opcode (inst: storage_inst): byte = 
match inst with 
| SLOAD -> 0X54 (*Load word from the storage *)
| SSTORE -> 0X55 (* Save word to the storage *)
end

let storage_inst_num (inst: storage_inst): st_num = 
match inst with 
| SLOAD -> (1, 1)(*Load word from the storage *)
| SSTORE -> (2, 0) (* Save word to the storage *)
end

(*Program Counter Operation *)
type pc_inst =
 | JUMP (*  Alter the program counter. *)
 | JUMPI (* Conditionally alter the program counter. *)
 | PC (* the current location in the code *)
 | JUMPDEST (* indicate jump destinations. *)

let pc_inst_opcode (inst: pc_inst): byte = match inst with
| JUMP -> 0X56
| JUMPI -> 0X57 (* Conditionally alter the program counter. *)
| PC -> 0X58 
| JUMPDEST -> 0X5b
end

let pc_inst_num (inst: pc_inst): st_num = match inst with
| JUMP -> (1, 0)
| JUMPI -> (2, 0)
| PC -> (0, 1)
| JUMPDEST -> (0, 0)
end


(* Stack Operations *)

(* 32 PUSH operations in total *)
(* The pushed value is represented by a list of bytes. *)

type stack_inst =
  | POP (* Remove item from stack *)
  | PUSH_N list byte (* pushing an element to the stack *) 
  | CALLDATALOAD (* push a word to the stack which is taken from the caller's data *)

exception PushError

let stack_inst_opcode (inst: stack_inst): list byte 
raises {PushError -> False}
= match inst with
| POP -> [0X50]
| PUSH_N lst ->
     if 1 <= length(lst) <= 32 then [uint8_of_int (length lst) + 0X5f] ++ lst else raise PushError 
     (* opcode of the operation ++ the pushed value list *)
| CALLDATALOAD -> [0X35]
end

let stack_inst_num (inst: stack_inst): st_num = match inst with
| POP -> (1, 0)
| PUSH_N _ -> (0, 1)
| CALLDATALOAD -> (1, 1)
end

(* The 16 insts for duplicating a stack element, take a stack element and copy it on top of the stack *)
type dup_inst = uint4

let dup_inst_opcode (inst: dup_inst): byte =
(uint8_of_int (uint4_to_int inst) + 0X80) 

let dup_inst_num (inst: dup_inst): st_num =
(uint4_to_int inst, (uint4_to_int inst) + 1 )

(* The 16 insts for taking a stack element and duplicate it on top of the stack.*)
type swap_inst = uint4

let swap_inst_opcode (inst: swap_inst): byte =
  (uint8_of_int (uint4_to_int inst) + 0X90)

let swap_inst_num (inst: swap_inst): st_num =
((uint4_to_int inst) + 1, (uint4_to_int inst) + 1)

(* Logging Operations *)
(* The state change is to append an additional log entry on to the substate’s log series *)
type log_inst =
| LOG0
| LOG1
| LOG2
| LOG3
| LOG4

let log_inst_opcode (inst: log_inst): byte = match inst with
| LOG0 -> 0Xa0
| LOG1 -> 0Xa1
| LOG2 -> 0Xa2
| LOG3 -> 0Xa3
| LOG4 -> 0Xa4
end

let log_inst_num (inst: log_inst): st_num = match inst with
| LOG0 -> (2, 0)
| LOG1 -> (3, 0)
| LOG2 -> (4, 0)
| LOG3 -> (5, 0)
| LOG4 -> (6, 0)
end

(* System Operations *)
type system_inst =
  | STOP (* finishing the execution normally, with the empty return data *)
  | CREATE (* deploying some code in an account *)
  | CALL (* calling (i.e. sending a message to) an account *)
  | CALLCODE (* calling into this account, but the executed code can be some other account's *)
  | RETURN (* finishing the execution normally with data *)
  | DELEGATECALL (* calling into this account, the executed code can be some other account's
                       but the sent value and the sent data are unchanged. *)
  | STATICCALL (* Static message-call into an account.*)
  | REVERT (* Halt execution reverting state changes but returning data and remaining gas. *)                      
  | SELFDESTRUCT (* send all remaining Eth balance to the specified account, *)
            (* finishing the execution normally, and flagging the current account for deletion *)

let system_inst_opcode (inst: system_inst): byte = match inst with
| STOP -> 0X00
| CREATE -> 0Xf0
| CALL -> 0Xf1
| CALLCODE -> 0Xf2
| RETURN -> 0Xf3
| DELEGATECALL -> 0Xf4
| STATICCALL -> 0Xfa
| REVERT -> 0Xfd
| SELFDESTRUCT -> 0Xff
end

let system_inst_num (inst: system_inst): st_num = match inst with
| STOP         -> (0, 0)
| CREATE       -> (3, 1)
| CALL         -> (7, 1)
| CALLCODE     -> (7, 1)
| RETURN       -> (2, 0)
| DELEGATECALL -> (6, 1)
| STATICCALL   -> (6, 1)
| REVERT       -> (2, 0)
| SELFDESTRUCT -> (1, 0)
end

(* Instruction Set *)
(* The previous operation sets above are here combined into a single type. *)

type instruction =
  | Unknown byte
  | Bits bits_inst
  | Sarith sign_arith_inst
  | Arith arith_inst
  | Info info_inst
  | Dup dup_inst
  | Memory memory_inst
  | Storage storage_inst
  | Pc pc_inst
  | Stack stack_inst
  | Swap swap_inst
  | Log log_inst
  | System system_inst

(*let to_list m = 
match m with
 | None -> Nil
 | Some s -> [s]
end*)


let inst_opcode (inst: instruction): list byte = match inst with
| Unknown byte -> [byte]
| Bits b -> [bits_inst_opcode b]
| Sarith s -> [sign_arith_inst_opcode s]
| Arith a -> [arith_inst_opcode a]
| Info i -> [info_inst_opcode i]
| Dup d -> [dup_inst_opcode d]
| Memory m -> [memory_inst_opcode m]
| Storage s -> [storage_inst_opcode s]
| Pc p -> [pc_inst_opcode p]
| Stack s -> stack_inst_opcode s
| Swap s -> [swap_inst_opcode s]
| Log l -> [log_inst_opcode l]
| System m -> [system_inst_opcode m]
end


let inst_stack_num (inst: instruction): st_num = match inst with
| Bits b -> bit_inst_num b
| Sarith s -> sign_arith_inst_num s
| Arith a -> arith_inst_num a
| Info i -> info_inst_num i
| Dup d -> dup_inst_num d
| Memory m -> memory_inst_num m
| Storage s -> storage_inst_num s
| Pc p -> pc_inst_num p
| Stack s -> stack_inst_num s
| Swap s -> swap_inst_num s
| Log l -> log_inst_num l
| System m -> system_inst_num m
end






(* Gas mechanism (Fee schedule) *)


let Gzero: int = 0
let Gbase: int = 2
let Gverylow: int = 3
let Glow: int = 5
let Gmid: int = 8
let Ghigh: int = 10
let Gextcode: int = 700 (* Amount of gas to pay for operations of the set Wextcode *)
let gas_of_Wzero (inst: instruction) : int =
  let Gas = match inst with
    | System STOP
    | System RETURN
    | System REVERT -> 0
    end
  in Gas

let gas_of_Wlow (inst: instruction) : int =
  let Gas = match inst with
    | Arith MUL
    | Arith DIV
    | Sarith SDIV
    | Arith MOD
    | Sarith SMOD
    | Sarith SIGNEXTEND-> 0
    end
  in Gas   

let Gbalance: int = 400
let Gsload: int = 200
let Gjumpdest: int = 1
let Gsset: int = 20000

let Gsreset: int = 5000
let Gselfdestruct: int = 5000

let Gcreate: int = 32000

let Gcodedeposit: int = 200
let Gcall: int = 700
let Gcallvalue: int = 9000

let Gcallstipend: int = 2300

let Gnewaccount: int = 25000

let Gexp: int = 10
let Gexpbyte: int = 50
let Gmemory: int = 3

let Gtxcreate: int = 32000

let Gtxdatazero: int = 4

let Gtxdatanonzero: int = 68

let Gtransaction: int = 21000

let Glog: int = 375

let Glogdata: int = 8

let Glogtopic: int = 375

let Gsha3: int = 30

let Gsha3word: int = 6

let Gcopy: int = 3

let Gblockhash: int = 20

let Gquaddivisor: int = 100

(* !!! Move to the preprocessor part: begin *)


type program = {
  program_content : int -> option instruction; 
  program_length  : int; (* the length of the program in bytes *)
}

let inst_list_of_program(p: program) (idx: int): byte =
   match p.program_content idx with
   | None -> 0
   | Some instruction ->
      match List.nth 0 (inst_opcode inst) with
      | None -> 0
      | Some a -> a
      end
   end


(* Move to the preprocessor part: end *)

(* Representation of the machine state part i.e. the volatile part *)
type machine_state = {
  mac_stack : stack ; (* In EVM definition, max length is 1024 *)
  mac_memory : memory;
  mac_pc : int;
  mac_status : vmstatus
  mac_memory_usage : int; (* the current memory usage *) 
  mac_gas : int; (* the remaining gas *)
  mac_insts : list instruction  (* Slight changes *)
  mac_jumpmap : uint256 -> uint
}



(* The result of a program execution is the results of its instructions contained in the program *)






(* Auxiliary functions for EVM instructions *)  

(* Auxiliary functions for memory *)
(* Memory initialization*)

let empty_memo: memory = fun addr: machword -> None

let rec update_memoContent (memo: memory) (idx: uint256) (cont: list memory_content) (n: int): memory 
requires {n >= 0}
=   match n with 
      | 0 -> memo
      | m + 1 -> 
        match cont with 
          | Nil -> memo
          | h :: t -> update_memoContent (fun addr -> if addr = idx then h else memo addr) (idx + 1) t m
        end
    end

let rec read_memoContent (idx: uint256) (n: int) (memo: memory): list memory_content
    requires {n >= 0}
= match n with 
    | 0 -> Nil
    | m + 1 -> memo idx :: read_memoContent (idx + 1) m memo
  end

let update_memory_content (m: memory) (idx: uint256) (cont: option memory_content): memory =
   fun addr -> if addr = idx then cont else (m addr)

(* Auxiliary functions for stack *)

let push_stack (s: stack) (ele: machword): stack = ele :: s

let pop_stack (s: stack): stack * option machword  = 
    match s with
    | ele :: (tl s) -> (tl s, Some ele)
    | _ -> (s, None) 
    end

let swap_stack (s: stack) (i: int): stack =
     let ele = List.nth i s in
        let top = List.nth 0 s in 
        s[i] <- top
        s[0] <- ele

(* Machine state update *)

let update_stack (st: stack) (m: machine_state) : machine_state =
{ m with mac_stack = st }   

let update_memory (memo: memory) (m: machine_state) : machine_state =
{ m with mac_memory = memo }  

let update_pc (pc: int) (m: machine_state) : machine_state =
{ m with mac_pc = pc }   

let update_status (vst: vmstatus) (m: machine_state) : machine_state =
{ m with mac_status = vst }  
(* Auxiliay function for the slight change in machine state to get the opcodes *)

let inc_pc (m: machine_state): machine_state =
  update_pc (m.mac_pc + 1) m
let get_inst (mac_st: machine_state): instruction =
  match mac_st with 
  | _ _ pc _ _ _ insts _ -> List.nth pc insts 
  end

(* Transformation semantics for different insturctions *)

let interpreter: machine_state -> machine_state =
   fun m -> 
   let inst = get_inst m in
   match inst with 
    | System STOP -> {m with mac_status = (Finish (Normal (uint256_of_int 0)))}
    | Arith ADD -> let (st', a) = (pop_stack (m.mac_stack)) in 
                   let (st'', b) = ( pop st') in 
                   inc_pc
                   match a, b with 
                   | Some a', Some b' -> {m with mac_stack = push_stack s'' (a + b)}
                   | _, _ -> {m with mac_status = (Error OutOfStack)}
                   end
    | Arith MUL -> let (st', a) = (pop_stack (m.mac_stack)) in 
                   let (st'', b) = ( pop st') in 
                   inc_pc
                   match a, b with 
                   | Some a', Some b' -> {m with mac_stack = push_stack s'' (a * b)}
                   | _, _ -> {m with mac_status = (Error OutOfStack)}
                   end
    | Arith SUB -> let (st', a) = (pop_stack (m.mac_stack)) in 
                   let (st'', b) = (pop st') in 
                   inc_pc
                   match a, b with 
                   | Some a', Some b' -> {m with mac_stack = push_stack s'' (a - b)}
                   | _, _ -> {m with mac_status = (Error OutOfStack)}
                   end

    | Arith DIV -> let (st', a) = (pop_stack (m.mac_stack)) in 
                   let (st'', b) = ( pop st') in 
                   inc_pc
                   match a, b with 
                   | Some a', Some b' -> {m with mac_stack = push_stack s'' (div a b)}
                   | _, _ -> {m with mac_status = (Error OutOfStack)}
                   end  
    | Arith MOD -> let (st', a) = (pop_stack (m.mac_stack)) in 
                   let (st'', b) = ( pop st') in 
                   inc_pc
                   match a, b with 
                   | Some a', Some b' -> {m with mac_stack = push_stack s'' (mod a b)}
                   | _, _ -> {m with mac_status = (Error OutOfStack)}
                   end     
    | Arith EXP -> let (st', a) = (pop_stack (m.mac_stack)) in 
                   let (st'', b) = ( pop st') in 
                   inc_pc
                   match a, b with 
                   | Some a', Some b' -> {m with mac_stack = push_stack s'' (power a b)}
                   | _, _ -> {m with mac_status = (Error OutOfStack)}
                   end  
    | Arith LT -> let (st', a) = (pop_stack (m.mac_stack)) in 
                   let (st'', b) = ( pop st') in 
                   inc_pc
                   match a, b with 
                   | Some a', Some b' -> {m with mac_stack = push_stack s'' (if a' < b' then (uint256_of_int 1) else (uint256_of_int 0) )
                   | _, _ -> {m with mac_status = (Error OutOfStack)}
                   end   
    | Stack POP -> let (st', a) = pop_stack (m.mac_stack) in 
                   inc_pc
                   match a with
                   | Some _ -> { m with mac_stack = s' } 
                   | None -> { m with mac_status = (Error OutOfStack) } 
                   end
    | Stack PUSH_N a -> inc_pc { m with mac_stack = (push_stack m.mac_stack  a) } 
    | Dup i     -> let ele = nth (i - 1) m.mac_stack in 
                  inc_pc
                  match ele with
                  | Some a -> { m with mac_stack = push_stack m.mac_stack a }
                  | None -> { m with mac_status = (Error OutOfStack) }
                  end
    | Swap i     -> let s = swap_stack m.mac_stack i in 
                  inc_pc
                  match s with
                  | Some a -> { m with mac_stack = s }
                  | None  ->  { m with mac_status = (Error OutOfStack) }
                  end
    | Pc JUMP    -> let (s', dest) = pop_stack m.mac_stack in 
                    match dest with 
                    | Some a -> {m with mac_stack = s'; mac_jumpmap = a
                    | None -> { m with mac_status = (Error OutOfStack) }
                    end
    | Pc JUMPI   -> let (s', dest) = pop_stack m.mac_stack in
                    let (s'', con) = pop_stack m.mac_stack in
                    match dest, con with 
                    | Some dest, Some con -> 
                         if con = uint256_of_int 0 then inc_pc {m with mac_stack = s'' }
                         else { m with mac_pc = (m.jumpmap dest) }
                    | _, _ -> { m with mac_status = (Error OutOfStack) } 
                    end
    | Pc JUMPDEST -> { m with m.mac_pc = m.mac_pc + 1 }
    | Memory MSTORE -> let (s', offset) = pop_stack m.mac_stack in 
                       let (s'', cont) = pop_stack s' in
                       inc_pc
                       match offset, cont with
                       | Some o, Some c -> {m with mac_stack = s''; mac_memory = update_memory_content m.mac_memory o (Some (Item256 c))} 
                       | _, _ -> { m with mac_status = (Error OutOfStack) } 
                       end
    | Memory MSTORE8 -> let (s', offset) = pop_stack m.mac_stack in 
                       let (s'', cont) = pop_stack s' in
                       inc_pc
                       match offset, cont with
                       | Some o, Some c -> {m with mac_stack = s''; mac_memory = update_memory_content m.mac_memory o (Some (Item8 c))} 
                       | _, _ -> { m with mac_status = (Error OutOfStack) } 
                       end

(* CALLDATALOAD for stack *)
(* MLOAD CALLDATACOPY for memory *)
