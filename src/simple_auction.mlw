module UInt160
	use mach.int.Unsigned
	type uint160
	constant max_uint160: int = 0xffffffffffffffffffffffffffffffffffffffff
	clone export mach.int.Unsigned with
		type t = uint160,
		constant max = max_uint160
end
module UInt
    use mach.int.Bounded_int
    type uint
    constant min_uint : int = 0
    clone export mach.int.Bounded_int with
        type t = uint,
        constant min = min_uint
end


module SimpleAuction
use int.Int
use bool.Bool
use ref.Ref
use map.Map
use int.ComputerDivision
use UInt160
use UInt

type address = uint160
exception Ret
let bid (bid_sender: address) (bid_value: uint) (highestBid: uint) (highestBidder: address)
    (pendingReturns: (map address uint)): (address, uint, uint)
    requires {bid_value > highestBid}
    requires {in_bounds ((pendingReturns highestBidder) + highestBid)}
    ensures {let bidder, value, amount = result in bidder = bid_sender && value > highestBid && amount >= highestBid}
    = 
    let _highestBid = ref highestBid in 
    let _highestBidder = ref highestBidder in 
    (* let _pendingReturns = ref pendingReturns in *)
    let _amountReturns = ref (pendingReturns highestBidder) in
    try
    begin
        if (!_highestBid <> of_int 0) then _amountReturns := !_amountReturns + highestBid;
    _highestBidder := bid_sender;
    _highestBid := bid_value;
    end;
    raise Ret
    with Ret -> !_highestBidder, !_highestBid, !_amountReturns
end

type pending_return_status = {
    return_user: address;
    return_amount: uint;
}
use real.Real
type auction_status = {
    highestBid: uint;
    highestBidder: address;
    beneficiary_amount: uint;
}
type auction_constant = {
    beneficiary : address;
    auctionEndTime : real
}

type auction_ended = {
    finalBidder: address;
    finalBid: uint
}
let update_return_amount (user: address) (amount: uint) (pending_st: pending_return_status): pending_return_status
    = {pending_st with return_user = user; return_amount = amount}

let conclude_auction (auc_st: auction_status) (auc_end: auction_ended) : auction_ended
    = {auc_end with finalBidder = auc_st.highestBidder; finalBid = auc_st.highestBid}

let withdraw (withdraw_sender: address) (withdraw_request: map address uint) 
    (pendingReturns: map address uint)(pending_st: pending_return_status): (bool, pending_return_status)
    requires {in_bounds 0}
    requires {withdraw_request withdraw_sender = pendingReturns withdraw_sender} 
    = 
    let pending_new_st = ref pending_st in 
    let return_amount = ref (pendingReturns withdraw_sender) in
    try
    begin
        if !return_amount <> UInt.of_int 0 then 
        return_amount := UInt.of_int 0; 
    end;
    pending_new_st := update_return_amount withdraw_sender !return_amount pending_st;
    raise Ret
    with Ret -> True, !pending_new_st
end

let auctionEnd (current_time: real) (auc_const: auction_constant) (auc_st: auction_status) (ended: bool) (auc_end: auction_ended): (bool, auction_ended) 
    requires { current_time >= auc_const.auctionEndTime}
    requires {ended = False}
    ensures {let (end_res, auc_end_status) = result in end_res = True -> auc_end_status.finalBidder = auc_st.highestBidder && auc_end_status.finalBid = auc_st.highestBid}
    = 
    let _ended = ref ended in
    let _auc_end = ref auc_end in 
    try
    begin
        _ended := True;
        _auc_end := conclude_auction auc_st auc_end
    end;
    raise Ret
    with Ret -> !_ended, !_auc_end 
end

end




