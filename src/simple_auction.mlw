module UInt160
	use mach.int.Unsigned
	type uint160
	constant max_uint160: int = 0xffffffffffffffffffffffffffffffffffffffff
	clone export mach.int.Unsigned with
		type t = uint160,
		constant max = max_uint160
end
module UInt
    use mach.int.Bounded_int
    type uint
    constant min_uint : int = 0
    clone export mach.int.Bounded_int with
        type t = uint,
        constant min = min_uint
end


module SimpleAuction
use int.Int
use bool.Bool
use ref.Ref
use map.Map
use int.ComputerDivision
use UInt160
use UInt

type address = uint160
exception Ret
let bid (bid_sender: address) (bid_value: uint) (highestBid: uint) (highestBidder: address)
    (pendingReturns: (map address uint)): (address, uint, uint)
    requires {bid_value > highestBid}
    requires {in_bounds ((pendingReturns highestBidder) + highestBid)}
    ensures {let bidder, value, amount = result in bidder = bid_sender && value > highestBid && amount >= highestBid}
    = 
    let _highestBid = ref highestBid in 
    let _highestBidder = ref highestBidder in 
    (* let _pendingReturns = ref pendingReturns in *)
    let _amountReturns = ref (pendingReturns highestBidder) in
    try
    begin
        if (!_highestBid <> of_int 0) then _amountReturns := !_amountReturns + highestBid;
    _highestBidder := bid_sender;
    _highestBid := bid_value;
    end;
    raise Ret
    with Ret -> !_highestBidder, !_highestBid, !_amountReturns
end

type pending_return_status = {
    return_user: address;
    return_amount: uint;
}
let update_return_amount (user: address) (amount: uint) (pending_st: pending_return_status): pending_return_status
    = {pending_st with return_user = user; return_amount = amount}

let withdraw (withdraw_sender: address) (withdraw_request: map address uint) 
    (pendingReturns: map address uint)(pending_st: pending_return_status): (bool, pending_return_status)
    requires {in_bounds 0}
    requires {withdraw_request withdraw_sender = pendingReturns withdraw_sender} 
    = 
    let pending_new_st = ref pending_st in 
    let return_amount = ref (pendingReturns withdraw_sender) in
    try
    begin
        if !return_amount <> UInt.of_int 0 then 
        return_amount := UInt.of_int 0; 
    end;
    pending_new_st := update_return_amount withdraw_sender !return_amount pending_st;
    raise Ret
    with Ret -> True, !pending_new_st
end
end

(* let auctionEnd (current_time: real) (auctionEndTime: real) (ended: ref bool): event 
    requires { current_time >= auctionEndTime}
    requires {ended = False}
    = 
    try
    begin
        ended := True
    end;
    raise Ret
    with Ret ->  *)




    (* let bid (bid_sender: address) (bid_value: uint) (auc_status: auction_status)
        (pendingReturns: map address uint): auction_status
        requires {bid_value > auc_status.highestBid}
        ensures {let (auction_bidder, auction_bid) = result in 
        auction_bidder = auction_status.highestBidder && auction_bid = auction_status.highestBid}
        = 
        let _highestBid = ref auc_status.highestBid in 
        let _highestBidder = ref auc_status.highestBidder in 
        try
        begin
            (* if (!_highestBid <> of_int 0) then 
                begin
                let _old_highest_bidder_value = !_pendingReturns !_highestBidder in
                !_pendingReturns !_highestBidder <-  (_old_highest_bidder_value + !_highestBid);
                end; *)
            _highestBidder := bid_sender;
            _highestBid := bid_value;
            auction_status.highestBidder = !_highestBidder
            auction_status.highestBidr = !_highestBid
        end;
        raise Ret
        with Ret -> !_highestBidder, !_highestBid
    end *)
(* let bid (bid_sender: address) (bid_value: uint) (auc_status: auction_status) (pendingReturns: array uint):
    auction_status
    requires {bid_value > auc_status.highestBid}
    ensures {auc_status.highestBidder = bid_sender && auc_status.highestBid = bid_value}
    = 
    try
    begin
        if ((to_int !auc_status.highestBid) <> 0) then 
        pendingReturns[to_int auc_status.highestBidder] = pendingReturns[to_int auc_status.highestBidder] + auc_status.highestBid;
        auc_status.highestBidder = bid_sender;
        auc_status.highestBid = bid_value;
    end;
    raise Ret
    with Ret -> auc_status
end*)